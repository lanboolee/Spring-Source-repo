## spring

## 1. 请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？

    a) ioc(控制反转)就是DI(依赖注入), 用来解决对象之间的耦合问题, ioc容器存放着对象.
    b) 实现IOC的步骤
       
       定义用来描述bean的配置的Java类
       
       解析bean的配置，將bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术
       
       遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中即可。
##   2.  spring是如何解决循环依赖问题的?
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        /**
         * 第一步:我们尝试去一级缓存(单例缓存池中去获取对象,一般情况从该map中获取的对象是直接可以使用的)
         * IOC容器初始化加载单实例bean的时候第一次进来的时候 该map中一般返回空
         */
        Object singletonObject = this.singletonObjects.get(beanName);
        /**
         * 若在第一级缓存中没有获取到对象,并且singletonsCurrentlyInCreation这个list包含该beanName
         * IOC容器初始化加载单实例bean的时候第一次进来的时候 该list中一般返回空,但是循环依赖的时候可以满足该条件
         */
        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
                /**
                 * 尝试去二级缓存中获取对象(二级缓存中的对象是一个早期对象)
                 * 何为早期对象:就是bean刚刚调用了构造方法，还来不及给bean的属性进行赋值的对象
                 * 就是早期对象
                 */
                singletonObject = this.earlySingletonObjects.get(beanName);
                /**
                 * 二级缓存中也没有获取到对象,allowEarlyReference为true(参数是有上一个方法传递进来的true)
                 */
                if (singletonObject == null && allowEarlyReference) {
                    /**
                     * 直接从三级缓存中获取 ObjectFactory对象 这个对接就是用来解决循环依赖的关键所在
                     * 在ioc后期的过程中,当bean调用了构造方法的时候,把早期对象包裹成一个ObjectFactory
                     * 暴露到三级缓存中
                     */
                    ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                    //从三级缓存中获取到对象不为空
                    if (singletonFactory != null) {
                        /**
                         * 在这里通过暴露的ObjectFactory 包装对象中,通过调用他的getObject()来获取我们的早期对象
                         * 在这个环节中会调用到 getEarlyBeanReference()来进行后置处理
                         */
                        singletonObject = singletonFactory.getObject();
                        //把早期对象放置在二级缓存,
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        //ObjectFactory 包装对象从三级缓存中删除掉
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }
        return singletonObject;
    }

## 3. AOP
    a) 为bean创建一个proxy，JDKproxy或者CGLIBproxy，然后在调用bean的方法时，会通过proxy来调用bean方法
       
           重点过程可分为：
       
           1）通过AspectJAutoProxyBeanDefinitionParser类将AnnotationAwareAspectJAutoProxyCreator注册到Spring容器中
       
           2）AnnotationAwareAspectJAutoProxyCreator类的postProcessAfterInitialization()方法将所有有advice的bean重新包装成proxy
       
           3）调用bean方法时通过proxy来调用，proxy依次调用增强器的相关方法，来实现方法切入
## 4. spring事务
    a) 七种传播行为 REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED 默认第一个
    
    b) 四种隔离级别 DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE, default是根据数据库默认的, mysql默认RR
    
    c) 事务源码解析@Transactional 是通过aop实现的, 在AutoProxyRegistrar类里执行registerBeanDefinitions 去注册benaDefinitions  
     在ProxyTransactionManagementConfiguration导入切面信息, setAdvice, advice是顶层接口, 主要aop用到, advice就是增强器接口
## 5. bean的生命周期
    a) ①通过构造器或工厂方法创建bean实例
       
       ②为bean的属性设置值和对其他bean的引用
       
       ③将bean实例传递给bean后置处理器的postProcessBeforeInitialization()方法
       
       ④调用bean的初始化方法
       
       ⑤将bean实例传递给bean后置处理器的postProcessAfterInitialization()方法
       
       ⑥bean可以使用了
       
       ⑦当容器关闭时调用bean的销毁方法
# JUC

## 1. 线程池
    a) 